<!DOCTYPE html>
<html xmlns='http://www.w3.org/1999/xhtml' lang='en-US'>

<head>
    <title>Simple game</title>
    <meta name='viewport' content='width=device-width, initial-scale=1.0' />
    <style>
        html,
        body {
            overflow-x: hidden;
            overflow-y: auto;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #scene {
            display: block;
            touch-action: none;
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <canvas id="scene"></canvas>
    <script src="OimoPhysics.min.js"></script>
    <script src="frag.js"></script>
    
    <script>
        const degToRad = Math.PI / 180;

        class TargetModel {
            constructor(game, color) {
                this.mesh = game.engine.Cylinder(8, { color });
                this.model = game.engine.Model()
                    .mesh(this.mesh)
                    .shader(game.shader)
                    .shadeSmooth();
                this.model.getPosition()
                    .scaleXYZ(4, 4, 8)
                    .rotateX(90 * degToRad);
            }

            dispose() {
                this.model.dispose();
                this.mesh.dispose();
            }
        }

        class Target {
            constructor(game, model, start, end, invSpeed) {
                this.object = game.engine.SceneObject(model.model);
                game.scene.addObject(this.object);

                const position = this.object.getPosition();
                position.location(start);
                
                const animationAction = game.engine.PositionAnimationAction(position, invSpeed)
                    .moveTo(end)
                    .onStop(() => { this.dispose(); });

                this.animation = game.engine.Animation()
                    .perform(animationAction)
                    .start();

                const shape = new window.OIMO.Shape();
                shape.setContactCallback(callback);
                this.transform = shape.getTransform();

                this.rigidBody = new window.OIMO.RigidBody();
                this.rigidBody.addShape(shape);
                game.physics.addRigidBody(this.rigidBody);
            }

            dispose() {
                this.animation.dispose();
                this.object.dispose();
            }
        }

        class BallModel {
            constructor(game, color) {
                this.mesh = game.engine.Sphere(8, { color });
                this.model = game.engine.Model()
                    .mesh(this.mesh)
                    .shader(game.shader)
                    .shadeSmooth();
                this.model.getPosition()
                    .scale(3);
            }

            dispose() {
                this.model.dispose();
                this.mesh.dispose();
            }
        }

        class Ball {
            constructor(game, ballModel) {
                this.object = game.engine.SceneObject(ballModel.model);
                game.scene.addObject(this.object);
            }

            dispose() {
                this.object.dispose();
            }
        }

        class Catapult {
            constructor(game) {
                this.game = game;
                this.mesh = game.engine.Cube(1, { color: [1, 0, 1] });
                this.model = game.engine.Model()
                    .mesh(this.mesh)
                    .shader(game.shader)
                    .shadeFlat();
                this.model.getPosition()
                    .scaleXYZ(20, 1, 2);
                this.object = game.engine.SceneObject(this.model);
                this.object.getPosition()
                    .locationY(-30)
                    .locationZ(15);
                game.scene.addObject(this.object);

                this.ballModels = [
                    new BallModel(game, [1, 0.4, 0.4]),
                    new BallModel(game, [0.4, 1, 0.4]),
                    new BallModel(game, [0.4, 0.4, 1])
                ];

                this.newBall();
            }

            dispose() {
                this.object.dispose();
                this.model.dispose();
                this.mesh.dispose();
            }

            newBall() {
                const ballModel = this.ballModels[Math.floor(Math.random() * this.ballModels.length)];
                this.ball = new Ball(this.game, ballModel);

                const thisLocation = this.object.getPosition().getLocation();
                const ballLocation = frag.Vector.add(thisLocation, [0, 4, 0]);
                this.ball.object.getPosition().location(ballLocation);

                setTimeout(() => { this.fire(); }, 3000);
            }

            fire() {
                if (!this.ball) return;

                const ball = this.ball;
                const ballPosition = ball.object.getPosition();
                
                const animationAction = game.engine.PositionAnimationAction(ballPosition, 1)
                    .moveBy([0, -40, 200])
                    .onStop(() => { ball.dispose(); });

                game.engine.Animation()
                    .perform(animationAction)
                    .disposeOnStop()
                    .start();
                    
                this.ball = null;

                setTimeout(() => { this.newBall(); }, 2000);
            }
        }

        class TargetGenerator {
            constructor(game) {
                const models = [
                    new TargetModel(game, [1, 0.4, 0.4]),
                    new TargetModel(game, [0.4, 1, 0.4]),
                    new TargetModel(game, [0.4, 0.4, 1]),
                ];

                this.interval = setInterval(() => {
                    if (Math.random() > 0.7) {
                        const model = models[Math.floor(Math.random() * models.length)];
                        const start = [
                            Math.random() > 0.5 ? 100 : -100, 
                            -50,
                            Math.random() * 100 + 50];
                        const end = [-start[0], start[1], start[2]];
                        const invSpeed = Math.random() * 5 + 1;
                        const target = new Target(game, model, start, end, invSpeed);
                    }
                }, 1000);
            }

            dispose() {
                this.cancelInterval(this.interval);
            }
        }

        class Floor {
            constructor(game) {
                this.mesh = game.engine.Plane(1, { color: [0.6, 0.6, 0.6] });
                this.model = game.engine.Model()
                    .mesh(this.mesh)
                    .shader(game.shader)
                    .shadeFlat();
                this.model.getPosition()
                    .scale(100)
                    .rotateX(90 * degToRad)
                    .locationY(-60)
                    .locationZ(100);
                this.object = game.engine.SceneObject(this.model);
                game.scene.addObject(this.object);

                // const shape = new window.OIMO.Shape(new window.OIMO.ShapeConfig());
                // this.transform = shape.getTransform();

                // this.rigidBody = new window.OIMO.RigidBody();
                // this.rigidBody.addShape(shape);
                // game.physics.addRigidBody(this.rigidBody);
            }

            dispose() {
                this.object.dispose();
                this.model.dispose();
                this.mesh.dispose();
            }
        }

        class Score {
            constructor(game) {
                this.game = game;
                this.score = 0;
                this.createFont();
                this.createText();
            }

            createFont() {
                // We would normally load a font asset, this is a hack 
                // to create a font texture by drawing text on a canvas

                const canvas = document.createElement("CANVAS");
                canvas.width = 256;
                canvas.height = 64;
                const context = canvas.getContext('2d');
                canvas.onload = function(){};

                //const body = document.getElementsByTagName("BODY")[0];
                //body.insertBefore(canvas, body.firstChild);

                context.beginPath();
                context.rect(0, 0, 256, 64);
                context.fillStyle = 'black';
                context.fill();

                context.font = '40px Calibri';
                context.fillStyle = 'white';
                context.fillText('0123456789', 0, 40);

                this.font = this.game.engine.Font()
                    .fromImage(canvas)
                    .backgroundColor([0, 0, 1, 0])
                    .textColor([0, 0, 1, 1])
                    .lineHeight(32)
                    .addChar('0',   0, 12, 20, 32, 0, 32, 22)
                    .addChar('1',  22, 12, 18, 32, 0, 32, 20)
                    .addChar('2',  40, 12, 20, 32, 0, 32, 22)
                    .addChar('3',  60, 12, 21, 32, 0, 32, 23)
                    .addChar('4',  80, 12, 22, 32, 0, 32, 24)
                    .addChar('5', 102, 12, 20, 32, 0, 32, 22)
                    .addChar('6', 122, 12, 21, 32, 0, 32, 23)
                    .addChar('7', 142, 12, 21, 32, 0, 32, 23)
                    .addChar('8', 162, 12, 21, 32, 0, 32, 23)
                    .addChar('9', 182, 12, 21, 32, 0, 32, 23);
            }

            createText() {
                this.model = this.font.buildTextModel('0');
                this.text = this.game.engine.SceneObject(this.model);
                this.text.getPosition().scale(0.5).locationXYZ(-20, -22, 145);
                this.game.scene.addObject(this.text);
            }

            setScore(score) {
                this.score = score;
                this.font.updateTextModel(this.model, score.toString());
            }

            add(score) {
                this.setScore(this.score + score);
            }
        }

        class PhysicsEngine {
            constructor(game) {
                this.physics = new window.OIMO.World(2, new window.OIMO.Vec3(0. -9.8, 0));
                this.animation = game.engine.Animation()
                    .repeatFrames(() => {
                        this.physics.step();
                    }, 1)
                    .start();
            }

            addRigidBody(body) {
                this.physics.addRigidBody(body);
            }

            setShapePosition(physicsShape, scenePosition) {
                const physicsTransform = physicsShape.getTransform();

                physicsTransform.rotateXyz(new window.OIMO.Vec3(
                    scenePosition.getRotateX(), 
                    scenePosition.getRotateY(),
                    scenePosition.getRotateZ()
                ));

                physicsTransform.setPosition(new window.OIMO.Vec3(
                    scenePosition.getLocationX(), 
                    scenePosition.getLocationY(),
                    scenePosition.getLocationZ()
                ));
            }

            setScenePosition(physicsShape, scenePosition) {
                const physicsTransform = physicsShape.getTransform();

                const position = physicsTransform.getPosition();
                // scenePosition.locationXYZ(position.x, position.y, position.z);

                const orientation = physicsTransform.getOrientation();
                // scenePosition.rotateXYZ();
            }

            dispose() {
                this.animation.dispose();
            }
        }

        class Game {
            constructor() {
                this.engine = window.frag.Engine().start();

                this.camera = this.engine.FrustumCamera().frustum(100, 100, 400);
                this.camera.getPosition().locationXYZ(0, 85, -10).rotateX(60 * degToRad);

                this.scene = this.engine.Scene().camera(this.camera);

                this.shader = this.engine.Shader().colorsRGB().directionalLightGrey().compile();
                this.shader.lightDirection([-0.2, -0.6, 0.1]);

                this.physics = new PhysicsEngine(this);
                this.score = new Score(this);
                this.engine.mainScene(this.scene);
            }

            addScore(score) {
                this.score.add(score);
            }

            dispose() {
                this.physics.dispose();
                this.shader.dispose();
                this.scene.dispose();
                this.camera.dispose();
                this.engine.dispose();
            }
        }

        const game = new Game();
        const floor = new Floor(game);
        const catapult = new Catapult(game);
        const generator = new TargetGenerator(game);

        setInterval(() => { 
            game.addScore(Math.floor(Math.random() * 10)); 
        }, 5000);
    </script>
</body>