<!DOCTYPE html>
<html xmlns='http://www.w3.org/1999/xhtml' lang='en-US'>

<head>
    <title>Simple game</title>
    <meta name='viewport' content='width=device-width, initial-scale=1.0' />
    <style>
        html,
        body {
            overflow-x: hidden;
            overflow-y: auto;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #scene {
            display: block;
            touch-action: none;
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <canvas id="scene"></canvas>
    <script src="oimo.min.js"></script>
    <script src="frag.js"></script>
    
    <script>
        const degToRad = Math.PI / 180;

        class TargetModel {
            constructor(game, color) {
                this.mesh = game.engine.Cylinder(8, { color });
                this.model = game.engine.Model()
                    .mesh(this.mesh)
                    .shader(game.shader)
                    .shadeSmooth();
                this.model.getPosition()
                    .scaleXYZ(4, 4, 8)
                    .rotateX(90 * degToRad);
            }

            dispose() {
                this.model.dispose();
                this.mesh.dispose();
            }
        }

        class Target {
            constructor(game, model, start, speed) {
                this.game = game;
                this.sceneObject = this.game.engine.SceneObject(model.model);
                this.game.scene.addObject(this.sceneObject);

                this.rigidBody = this.game.physics.add(
                    this, 
                    {
                        type: 'cylinder',
                        size: [8, 8, 16],
                        pos: start,
                        rot: [90, 0, 0],
                        move: true,
                        density: 1,
                        friction: 0.2,
                        restitution: 0.2,
                        belongsTo: 1,
                        collidesWith: 0xff,
                    });
                if (start[0] < 0)
                    this.rigidBody.linearVelocity.set(speed, 0, 0);
                else
                    this.rigidBody.linearVelocity.set(-speed, 0, 0);
            }

            dispose() {
                this.game.physics.remove(this.rigidBody);
                this.sceneObject.dispose();
            }
        }

        class BallModel {
            constructor(game, color) {
                this.mesh = game.engine.Sphere(8, { color });
                this.model = game.engine.Model()
                    .mesh(this.mesh)
                    .shader(game.shader)
                    .shadeSmooth();
                this.model.getPosition()
                    .scale(3);
            }

            dispose() {
                this.model.dispose();
                this.mesh.dispose();
            }
        }

        class Ball {
            constructor(game, ballModel, pos) {
                this.game = game;
                this.sceneObject = this.game.engine.SceneObject(ballModel.model);
                this.game.scene.addObject(this.sceneObject);

                this.rigidBody = this.game.physics.add(
                        this, 
                        {
                            type: 'sphere',
                            size: [6, 6, 6],
                            pos: pos,
                            rot: [0, 0, 0],
                            move: true,
                            density: 5,
                            friction: 0.2,
                            restitution: 0.2,
                            belongsTo: 1,
                            collidesWith: 0xff,
                        });
            }

            dispose() {
                this.game.physics.remove(this.rigidBody);
                this.sceneObject.dispose();
            }
        }

        class Catapult {
            constructor(game) {
                this.game = game;
                this.mesh = game.engine.Cube(1, { color: [1, 0, 1] });
                this.model = game.engine.Model()
                    .mesh(this.mesh)
                    .shader(game.shader)
                    .shadeFlat();
                this.model.getPosition()
                    .scaleXYZ(20, 1, 2);
                this.sceneObject = game.engine.SceneObject(this.model);
                this.sceneObject.getPosition()
                    .locationY(-50)
                    .locationZ(15);
                game.scene.addObject(this.sceneObject);

                this.ballModels = [
                    new BallModel(game, [1, 0.4, 0.4]),
                    new BallModel(game, [0.4, 1, 0.4]),
                    new BallModel(game, [0.4, 0.4, 1])
                ];

                this.rigidBody = game.physics.add(
                    this,
                    {
                        type: 'box',
                        size: [20, 1, 2],
                        pos: [0, -50, 15],
                        rot: [90, 0, 0],
                        move: false,
                        density: 1,
                        friction: 0.2,
                        restitution: 0.2,
                        belongsTo: 1,
                        collidesWith: 0xff,
                    });

                this.newBall();
            }

            dispose() {
                this.game.physics.remove(this.rigidBody);
                this.sceneObject.dispose();
                this.model.dispose();
                this.mesh.dispose();
            }

            newBall() {
                const thisLocation = this.sceneObject.getPosition().getLocation();
                const ballLocation = frag.Vector.add(thisLocation, [0, 4, 0]);
                const ballModel = this.ballModels[Math.floor(Math.random() * this.ballModels.length)];
                this.ball = new Ball(this.game, ballModel, ballLocation);

                setTimeout(() => { this.fire(); }, 3000);
            }

            fire() {
                if (!this.ball) return;

                this.ball.rigidBody.linearVelocity.set(0, 0, 100);
                this.ball = null;

                setTimeout(() => { this.newBall(); }, 2000);
            }
        }

        class TargetGenerator {
            constructor(game) {
                const models = [
                    new TargetModel(game, [1, 0.4, 0.4]),
                    new TargetModel(game, [0.4, 1, 0.4]),
                    new TargetModel(game, [0.4, 0.4, 1]),
                ];

                this.interval = setInterval(() => {
                    if (Math.random() > 0.7) {
                        const model = models[Math.floor(Math.random() * models.length)];
                        const position = [
                            Math.random() > 0.5 ? 100 : -100, 
                            -50,
                            Math.random() * 100 + 50];
                        const speed = Math.random() * 50 + 10;
                        const target = new Target(game, model, position, speed);
                    }
                }, 1000);
            }

            dispose() {
                this.cancelInterval(this.interval);
            }
        }

        class Floor {
            constructor(game) {
                this.game = game;
                this.mesh = game.engine.Plane(1, { color: [0.6, 0.6, 0.6] });
                this.model = game.engine.Model()
                    .mesh(this.mesh)
                    .shader(this.game.shader)
                    .shadeFlat();
                this.model.getPosition()
                    .scale(100);
                this.sceneObject = this.game.engine.SceneObject(this.model);
                this.sceneObject.getPosition()
                    .rotateX(90 * degToRad)
                    .locationY(-60)
                    .locationZ(100);
                    this.game.scene.addObject(this.sceneObject);

                this.rigidBody = game.physics.add(
                    this,
                    {
                        type: 'box',
                        size: [200, 200, 1],
                        pos: [0, -60, 100],
                        rot: [90, 0, 0],
                        move: false,
                        density: 1,
                        friction: 0.2,
                        restitution: 0.2,
                        belongsTo: 1,
                        collidesWith: 0xff,
                    });
            }

            dispose() {
                this.game.physics.remove(this.rigidBody);
                this.sceneObject.dispose();
                this.model.dispose();
                this.mesh.dispose();
            }
        }

        class Score {
            constructor(game) {
                this.game = game;
                this.score = 0;
                this.createFont();
                this.createText();
            }

            createFont() {
                // We would normally load a font asset, this is a hack 
                // to create a font texture by drawing text on a canvas

                const canvas = document.createElement("CANVAS");
                canvas.width = 256;
                canvas.height = 64;
                const context = canvas.getContext('2d');
                canvas.onload = function(){};

                //const body = document.getElementsByTagName("BODY")[0];
                //body.insertBefore(canvas, body.firstChild);

                context.beginPath();
                context.rect(0, 0, 256, 64);
                context.fillStyle = 'black';
                context.fill();

                context.font = '40px Calibri';
                context.fillStyle = 'white';
                context.fillText('0123456789', 0, 40);

                this.font = this.game.engine.Font()
                    .fromImage(canvas)
                    .backgroundColor([0, 0, 1, 0])
                    .textColor([0, 0, 1, 1])
                    .lineHeight(32)
                    .addChar('0',   0, 12, 20, 32, 0, 32, 22)
                    .addChar('1',  22, 12, 18, 32, 0, 32, 20)
                    .addChar('2',  40, 12, 20, 32, 0, 32, 22)
                    .addChar('3',  60, 12, 21, 32, 0, 32, 23)
                    .addChar('4',  80, 12, 22, 32, 0, 32, 24)
                    .addChar('5', 102, 12, 20, 32, 0, 32, 22)
                    .addChar('6', 122, 12, 21, 32, 0, 32, 23)
                    .addChar('7', 142, 12, 21, 32, 0, 32, 23)
                    .addChar('8', 162, 12, 21, 32, 0, 32, 23)
                    .addChar('9', 182, 12, 21, 32, 0, 32, 23);
            }

            createText() {
                this.model = this.font.buildTextModel('0');
                this.text = this.game.engine.SceneObject(this.model);
                this.text.getPosition().scale(0.5).locationXYZ(-20, -22, 145);
                this.game.scene.addObject(this.text);
            }

            setScore(score) {
                this.score = score;
                this.font.updateTextModel(this.model, score.toString());
            }

            add(score) {
                this.setScore(this.score + score);
            }
        }

        class PhysicsEngine {
            constructor(game) {
                this.objects = [];
                this.physics = new window.OIMO.World({
                    timestep: 1/50,
                    iterations: 8,
                    broadphase: 2,
                    worlscale: 1,
                    random: false,
                    info: false,
                    gravity: [0, -9.8, 0]
                });
                this.animation = game.engine.Animation()
                    .repeatTicks(() => {
                        this.physics.step();
                        for (var i = 0; i < this.objects.length; i++) {
                            const object = this.objects[i];
                            const element = object.element;
                            const rigidBody = object.rigidBody;
                            const pos = element.sceneObject.getPosition();
                            this.copyPosition(rigidBody, pos);

                            const location = pos.getLocation();
                            if (location[1] < -90) {
                                element.dispose();
                                this.objects.splice(i, 1);
                                i--;
                            }
                        }
                    }, 2)
                    .start();
            }

            add(element, bodyData) {
                const rigidBody = this.physics.add(bodyData);
                this.objects.push({
                    element,
                    rigidBody
                });
                return rigidBody;
            }

            remove(rigidBody) {
                this.physics.removeRigidBody(rigidBody);
            }

            copyPosition(rigidBody, scenePosition) {
                const pos = rigidBody.getPosition();
                scenePosition.locationXYZ(pos.x, pos.y, pos.z);

                const quad = rigidBody.getQuaternion();
                scenePosition.rotate([0, 0, 0, 0]);
            }

            dispose() {
                this.animation.dispose();
            }
        }

        class Game {
            constructor() {
                this.engine = window.frag.Engine().start();

                this.camera = this.engine.FrustumCamera().frustum(100, 100, 400);
                this.camera.getPosition().locationXYZ(0, 85, -10).rotateX(60 * degToRad);

                this.scene = this.engine.Scene().camera(this.camera);

                this.shader = this.engine.Shader().colorsRGB().directionalLightGrey().compile();
                this.shader.lightDirection([-0.2, -0.6, 0.1]);

                this.physics = new PhysicsEngine(this);
                this.score = new Score(this);
                this.engine.mainScene(this.scene);
            }

            addScore(score) {
                this.score.add(score);
            }

            dispose() {
                this.physics.dispose();
                this.shader.dispose();
                this.scene.dispose();
                this.camera.dispose();
                this.engine.dispose();
            }
        }

        const game = new Game();
        const floor = new Floor(game);
        const catapult = new Catapult(game);
        const generator = new TargetGenerator(game);

        setInterval(() => { 
            game.addScore(Math.floor(Math.random() * 10)); 
        }, 5000);
    </script>
</body>