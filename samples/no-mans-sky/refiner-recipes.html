<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
  <head>
    <title>No Man's Sky Refiner Recipes</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      html,
      body {
        overflow: hidden;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
      }

      #scene {
        width: 100vw;
        height: 100vh;
        touch-action: none;
        display: block;
      }
    </style>
  </head>
  <body>
    <canvas id="scene"></canvas>
    <script src="/frag.js"></script>
    <script src="ingredients.js"></script>
    <script src="recipies.js"></script>
    <script src="constants.js"></script>
    <script>
      // Calculate useful values form the raw data

      function lookupIngredient(name) {
        for (let i = 0; i < ingredients.length; i++) {
          const ingredient  = ingredients[i]
          if (ingredient.name == name) return ingredient
        }
        console.error(`Ingredient "` + name + '" is not defined')
      }

      for (let i = 0; i < ingredients.length; i++) {
        const ingredient = ingredients[i];
        ingredient.index = i;
        ingredient.recipeCount = 0
      }

      for (let i = 0; i < recipies.length; i++) {
        const recipe = recipies[i];
        recipe[0] = lookupIngredient(recipe[0])
        recipe[0].recipeCount++
        for (let j = 0; j < recipe[1].length; j++) {
          recipe[1][j] = lookupIngredient(recipe[1][j])
          recipe[1][j].recipeCount++
        }
      }

      for (let i = 0; i < ingredients.length; i++) {
        const ingredient = ingredients[i];
        ingredient.enabled = ingredient.recipeCount > 0
        ingredient.mass = 1000 + ingredient.recipeCount * 500;
      }

      // Initialize the Frag engine

      const sceneCanvas = document.getElementById("scene");
      const frag = window.frag;
      const engine = frag
        .Engine({ canvas: sceneCanvas })
        .onStart((engine) => {
          engine.gl.clearColor(0, 0, 0, 1);
          engine.gl.disable(engine.gl.CULL_FACE); // Pipes are open at the ends and we want to see the inside surface
        });
      engine.start();

      const degToRad = Math.PI / 180;

      // Set up the camera to view the scene
      const camera = frag.FrustumCamera(engine).frustum(50, 50, 2000);
      camera.getPosition().locationZ(-150);

      // Create the scene
      const scene = frag.Scene(engine).camera(camera);
      engine.mainScene(scene);

      // Create a parent object representing the recipe graph so that we can rotate it within the scene
      const recipeGraph = frag.SceneObject(engine);
      scene.addObject(recipeGraph);

      // Define a shared ingredient elements
      const ingredientShader = frag.Shader(engine).diffuseTexture().directionalLightGrey().compile().lightDirection([-0.2, -0.6, 0.1]);
      
      let ingredientMesh;
      switch (ingredientShape) {
        case 'disc':
          ingredientMesh = frag.Disc(engine, 16);
          break;
        case 'hemisphere':
          ingredientMesh = frag.Sphere(engine, 16, {
            longitudeFacets: 16,
            longitudeStart: Math.PI * 0.5,
            longitudeLength: Math.PI
          })
          break;
        case 'sphere':
          ingredientMesh = frag.Sphere(engine, 16)
          break;
      }


      // Augment each ingredient with additional information needed to animate it
      for (let i = 0; i < ingredients.length; i++) {
        const ingredient = ingredients[i];
        if (!ingredient.recipeCount) continue

        ingredient.position = [
          (Math.random() - 0.5) * 20,
          (Math.random() - 0.5) * 20,
          (Math.random() - 0.5) * 20,
        ];
        ingredient.velocity = [0, 0, 0];

        const diffuseTexture = frag.Texture(engine).dataFormat(engine.gl.RGB)
        if (ingredient.textureUrl) diffuseTexture.fromUrl(0, ingredient.textureUrl);
        else if (ingredient.color) diffuseTexture.fromArrayBuffer(0, new Uint8Array(frag.Vector.mult(ingredient.color, 255)), 0, 1, 1);
        else diffuseTexture.fromArrayBuffer(0, new Uint8Array([Math.floor(Math.random() * 128 + 128), Math.floor(Math.random() * 128 + 128), Math.floor(Math.random() * 128 + 128)]), 0, 1, 1);

        const material = frag.Material(engine)
          .setTexture('diffuse', diffuseTexture);

        ingredient.sceneObject = frag.SceneObject(engine, 
          frag.Model(engine)
            .mesh(ingredientMesh)
            .material(material)
            .shader(ingredientShader)
        );

        ingredient.sceneObject.getPosition()
          .scale(ingredientRadius)
          .location(ingredient.position);

        switch (ingredientShape) {
          case 'hemisphere':
          case 'sphere':
            ingredient.sceneObject.getPosition().rotateY(Math.PI * -0.5)
        }

        recipeGraph.addObject(ingredient.sceneObject);
      }

      // Define a shared recipe elements

      const recipeShader = frag.Shader(engine).colorsRGB().directionalLightGrey().compile().lightDirection([-0.2, -0.6, 0.1]);
      const recipeModel = frag.Model(engine).mesh(frag.Sphere(engine, 8, { color: [1, 1, 1] }).shadeSmooth()).shader(recipeShader);

      // Augment each recipe with with additional information needed to animate it

      for (let i = 0; i < recipies.length; i++) {
        const recipe = recipies[i];
        recipe.position = [0, 0, 0];
        recipe.sceneObject = frag.SceneObject(engine, recipeModel);

        recipe.sceneObject.getPosition()
          .scale(recipeRadius)
          .location(recipe.position);

        recipeGraph.addObject(recipe.sceneObject);
      }

      // Define a shared pipe elements

      const pipeShader = frag.Shader(engine).colorsRGB().directionalLightGrey().compile().lightDirection([-0.2, -0.6, 0.1]);
      const inputPipeMesh = frag.Cylinder(engine, 8, { color: [0.3, 0.3, 1] }).shadeSmooth();
      const outputPipeMesh = frag.Cylinder(engine, 8, { color: [1, 0.3, 0.3] }).shadeSmooth();

      // Add pipes to recipe inputs and outputs to connect to the ingredients
      for (let i = 0; i < recipies.length; i++) {
        const recipe = recipies[i];

        recipe.pipes = [{
          ingredient: recipe[0],
          mesh: outputPipeMesh,
        }];

        for (let j = 0; j < recipe[1].length; j++) {
          recipe.pipes.push({
            ingredient: recipe[1][j],
            mesh: inputPipeMesh,
          });
        }

        for (let j = 0; j < recipe.pipes.length; j++) {
          const pipe = recipe.pipes[j];
          pipe.sceneObject = frag.SceneObject(engine, frag.Model(engine).mesh(pipe.mesh).shader(pipeShader).shadeSmooth());
          pipe.sceneObject.getPosition().scaleXYZ(pipeRadius, pipeRadius, 1)
          recipeGraph.addObject(pipe.sceneObject);
        }
      }

      function simulatePhysics() {
        // Start from all ingredeints having no force applied to them
        const forces = [];
        for (let i = 0; i < ingredients.length; i++) forces[i] = [0, 0, 0];

        // All ingredients repel each other
        for (let i = 0; i < ingredients.length; i++) {
          const ingredientA = ingredients[i];
          if (!ingredientA.recipeCount) continue
          for (let j = i + 1; j < ingredients.length; j++) {
            const ingredientB = ingredients[j];
            if (!ingredientB.recipeCount) continue
            const aMinusB = frag.Vector.sub(ingredientA.position, ingredientB.position);
            const distance = frag.Vector.length(aMinusB);
            const direction = frag.Vector.normalize(aMinusB);
            const repulsionMagnitude =
              (repulsionStrength * Math.exp(-repulsionDecay * distance)) /
              (distance * distance);
            const repulsionForce = frag.Vector.mult(direction, repulsionMagnitude);
            forces[i] = frag.Vector.add(forces[i], repulsionForce);
            forces[j] = frag.Vector.sub(forces[j], repulsionForce);
          }
        }

        // All Ingredients are attracted to the origin
        for (let i = 0; i < ingredients.length; i++) {
          const ingredient = ingredients[i];
          if (!ingredient.recipeCount) continue
          const distanceFromOrigin = frag.Vector.length(ingredient.position);
          const direction = frag.Vector.normalize(ingredient.position);
          const attractionMagnitude = -originAttractionStrength * distanceFromOrigin;
          const attractionForce = frag.Vector.mult(direction, attractionMagnitude);
          forces[i] = frag.Vector.add(forces[i], attractionForce);
        }

        // Ingredients that are connected by a recipe are attracted to each other
        for (let i = 0; i < recipies.length; i++) {
          const recipe = recipies[i];
          const outputIngredient = recipe[0];
          for (let j = 0; j < recipe[1].length; j++) {
            const inputIngredient = recipe[1][j];
            const aMinusB = frag.Vector.sub(outputIngredient.position, inputIngredient.position);
            const distance = frag.Vector.length(aMinusB);
            const direction = frag.Vector.normalize(aMinusB);
            const attractionMagnitude = -recipeAttractionStrength * distance / (outputIngredient.mass + inputIngredient.mass);
            const attractionForce = frag.Vector.mult(direction, attractionMagnitude);
            forces[outputIngredient.index] = frag.Vector.add(forces[outputIngredient.index], attractionForce);
            forces[inputIngredient.index] = frag.Vector.sub(forces[inputIngredient.index], attractionForce);
          }
        }

        // Update velocities and positions of ingredients
        elapsedTime = 1 / 100;
        for (let i = 0; i < ingredients.length; i++) {
          const ingredient = ingredients[i];
          if (!ingredient.recipeCount) continue
          const force = forces[i];
          const acceleration = frag.Vector.div(force, ingredient.mass);

          ingredient.velocity = frag.Vector.mult(frag.Vector.add(ingredient.velocity, acceleration), velocityDamping);
          ingredient.position = frag.Vector.add(ingredient.position, frag.Vector.mult(ingredient.velocity, elapsedTime));

          ingredient.sceneObject.getPosition().location(ingredient.position);
        }

        // Position recipes to be at the centroid of their ingredients
        for (let i = 0; i < recipies.length; i++) {
          const recipe = recipies[i];

          let sum = recipe[0].position;
          for (let j = 0; j < recipe[1].length; j++)
            sum = frag.Vector.add(sum, recipe[1][j].position);

          recipe.position = frag.Vector.div(sum, recipe[1].length + 1);
          recipe.sceneObject.getPosition().location(recipe.position);
        }

        // Position pipes to connect recipes to their ingredients
        for (let i = 0; i < recipies.length; i++) {
          const recipe = recipies[i];
          for (let j = 0; j < recipe.pipes.length; j++) {
            const pipe = recipe.pipes[j];
            const ingredient = pipe.ingredient;

            const direction = frag.Vector.sub(ingredient.position, recipe.position);
            const distance = frag.Vector.length(direction);

            if (distance < 0.01) {
              pipe.sceneObject.getPosition().scaleXYZ(0, 0, 0);
              continue;
            }

            const midpoint = frag.Vector.add(recipe.position, frag.Vector.mult(direction, 0.5));
            const angle = frag.Vector.angles(direction, [0, 0, 1]);

            pipe.sceneObject.getPosition().location(midpoint).scaleZ(distance / 2).rotate(angle);
          }
        }
      }

      // Allow the user to translate the scene by dragging with the left mouse
      let sceneLocationX, sceneLocationY
      function updateSceneLocation() {
        recipeGraph.getPosition().locationXYZ(sceneLocationX.value, sceneLocationY.value, 0);
      };

      sceneLocationX = engine.AnalogState(updateSceneLocation, { value: 0, minValue: -100, maxValue: 100 });
      sceneLocationY = engine.AnalogState(updateSceneLocation, { value: 0, minValue: -100, maxValue: 100 });
      
      engine.AnalogInput("left-pointer", sceneLocationX).enable();
      engine.AnalogInput("left-pointer-vertical-inverted", sceneLocationY).enable();

      // Allow the user to rotate the scene by dragging with the right mouse
      let sceneRotationX, sceneRotationY
      function updateSceneRotation() {
        recipeGraph.getPosition().rotateXYZ(sceneRotationX.value, sceneRotationY.value, 0);
      };

      sceneRotationX = engine.AnalogState(updateSceneRotation, { value: 0, minValue: -90 * degToRad, maxValue: 90 * degToRad });
      sceneRotationY = engine.AnalogState(updateSceneRotation, { value: 0, minValue: -90 * degToRad, maxValue: 90 * degToRad });
      
      engine.AnalogInput("right-pointer-vertical-inverted", sceneRotationX).enable();
      engine.AnalogInput("right-pointer-inverted", sceneRotationY).enable();

      // Run the physics simulation continuously
      const physicsAnimation = frag.Animation(engine).repeatTicks(simulatePhysics, 1).start();
    </script>
  </body>
</html>
