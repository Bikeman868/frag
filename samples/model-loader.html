<!DOCTYPE html>
<html xmlns='http://www.w3.org/1999/xhtml' lang='en-US'>
<head>
    <title>Model Loader</title>
    <meta name='viewport' content='width=device-width, initial-scale=1.0' />
    <style>
        html,
        body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #scene {
            width: 100vw;
            height: 100vh;
            touch-action: none;
            display: block;
        }
    </style>
</head>
<body>
    <canvas id='scene'></canvas>
    <script src='frag.min.js'></script>
    <script>
        const frag = window.frag;

        frag.config = function() {
            frag.debugModelLoader = true;
            frag.debugAnimations = false;
            frag.debugShaderBuilder = false;
            frag.debugInputs = true;
        }
        frag.init();

        const degToRad = Math.PI / 180;

        const camera = frag.PerspectiveCamera()
            .frustrum(35 * degToRad, -100, 100)
            .scaleX(100)
            .moveToZ(-120);

        const scene = frag.Scene()
            .camera(camera);

        frag.mainScene(scene);

        // We will pass this function to the model loader. It will get called
        // after the models have finished loading into an asset catalog. The
        // asset catalog that the models were loaded into is passed as a parameter
        const modelsLoaded = function(assetCatalog) {

            // Get the "excavator" model that was loaded
            const excavatorModel = assetCatalog.getModel('excavator_nla')
                //.drawNormals(0.5, [255, 0, 0], 1)
                //.shadeFlat()
                .shadeSmooth()
                ;

            // Create an excavator from the model and add it to the scene
            const excavator = frag.SceneObject(excavatorModel);
            excavator.getPosition().scale(10).rotateY(-15 * degToRad).rotateX(-15 * degToRad).moveByXYZ(0, -30, 0);
            scene.addObject(excavator);

            // Next we are going to define an animation sequence for
            // the excavator that has five steps as follows:

            const invLinearVelocity = 3;
            const position = excavator.getPosition();

            // Step 1 in the animation sequence
            // Move the excavator from 0 to -80 on the x-axis
            // whilst running the "moving" animation
            const step1 = frag.PositionAnimationAction(position, invLinearVelocity)
                .moveTo([-80, -30, 0])
                .onStart(excavator.animations.moving.start)
                .onStop(excavator.animations.moving.stop);

            // Step 2 in the animation sequence
            // Run the "excavating" animation 4 times
            const step2 = frag.RepeatAnimationAction(excavator.animations.excavating, 4)

            // Step 3 in the animation sequence
            // Move the excavator from -80 to +20 on the x-axis
            // whilst running the "moving" animation
            const step3 = frag.PositionAnimationAction(position, invLinearVelocity)
                .moveBy([100, 0, 0])
                .onStart(excavator.animations.moving.start)
                .onStop(excavator.animations.moving.stop);

            // Step 4 in the animation sequence
            // Run the "tipping" animation exactly once
            const step4 = excavator.animations.tipping;

            // Step 5 in the animation sequence
            // Move the excavator from +20 back to 0 on the x-axis so that the animation can loop
            // whilst running the "moving" animation
            const step5 = frag.PositionAnimationAction(position, invLinearVelocity)
                .moveBy([-20, 0, 0])
                .onStart(excavator.animations.moving.start)
                .onStop(excavator.animations.moving.stop);

            // Add the animation sequence and start it running
            const animation = frag.Animation().sequence([step1, step2, step3, step4, step5], true);
            animation.start();

            // Define a custom wireframe display on/off state
            let wireframeModel = null;
            const wireframeStateChange = function(state, evt) {
                if (state.isOn) {
                    const hit = frag.hitTest(evt.clientX, evt.clientY);
                    if (hit) {
                        wireframeModel = hit.model;
                        wireframeModel.wireframe(true);
                    }
                } else {
                    if (wireframeModel) {
                        wireframeModel.wireframe(false);
                        wireframeModel = null;
                    }
                }
            };
            const wireframeState = frag.DigitalState(wireframeStateChange, { isOn: false }, "wireframe");

            // Define a custom normals display on/off state
            let normalsModel = null;
            const normalsStateChange = function(state, evt) {
                if (state.isOn) {
                    const hit = frag.hitTest(evt.clientX, evt.clientY);
                    if (hit) {
                        normalsModel = hit.model;
                        normalsModel.drawNormals(1);
                    }
                } else {
                    if (normalsModel) {
                        normalsModel.drawNormals(0);
                        normalsModel = null;
                    }
                }
            }
            const normalsState = frag.DigitalState(normalsStateChange, { isOn: false }, "normals");

            // Use DigitalAction to define some other on/off states that the player can control with inputs

            const excavatorVisibilityState = frag.DigitalState(
                frag.DigitalAction("sceneobject", { sceneObject: excavator }), 
                { isOn: true }, 
                "excavator visibility");

            const excavatorModelChildren = [];
            excavatorModel.addFlattenedChildren(excavatorModelChildren, (child) => child.getName() === "bucket");
            const bucketVisibilityState = frag.DigitalState(
                frag.DigitalAction("model", { model: excavatorModelChildren[0] }), 
                { isOn: true }, 
                "bucket visibility");

            const customState = frag.DigitalState(
                (digitalState) => { console.log("Custom digital state is " + (digitalState.isOn ? "on" : "off")) },
                { isOn: false },
                "custom flag");

            const animationState = frag.DigitalState(
                frag.DigitalAction("animation", { animation }),
                { isOn: true },
                "animation running");

            // Use AnalogState to define some continuously variable states that the player can control with inputs

            const cameraZoomState = frag.AnalogState(
                (analogState) => { camera.moveToZ(analogState.value); },
                {   value: -120,
                    minValue: -500,
                    maxValue: 0,
                    maxVelocity: 20,
                    acceleration: 0.5,
                    deceleration: 2,
                },
                "camera zoom");

            const cameraPanXState = frag.AnalogState(
                (analogState) => { camera.moveToX(analogState.value); },
                {   value: 0,
                    minValue: -100,
                    maxValue: 100,
                },
                "camera pan X");

            const cameraPanYState = frag.AnalogState(
                (analogState) => { camera.moveToY(analogState.value); },
                {   value: 0,
                    minValue: -100,
                    maxValue: 100,
                },
                "camera pan Y");

            // Group inputs together so that they can be turned on and off as a set
            const inputs = frag.InputMethod()
                .add(frag.DigitalInput("middle-mouse", wireframeState))
                .add(frag.DigitalInput("right-mouse", normalsState))
                .add(frag.DigitalInput("key-ctrl-a", customState))
                .add(frag.DigitalInput("key-q-toggle", excavatorVisibilityState))
                .add(frag.DigitalInput("key-e-toggle", bucketVisibilityState))
                .add(frag.DigitalInput("key-r-toggle", animationState))
                .add(frag.DigitalInput("key-t-inverted", animationState))
                .add(frag.DigitalInput("key-y-off", animationState))
                .add(frag.DigitalInput("key-u-on", animationState))
                .add(frag.AnalogInput("mouse-wheel", cameraZoomState))
                .add(frag.AnalogInput("mouse-left-horizontal-inverted", cameraPanXState))
                .add(frag.AnalogInput("mouse-left-vertical", cameraPanYState))
                .add(frag.AnalogInput("keys-d-a", cameraPanXState))
                .add(frag.AnalogInput("keys-w-s", cameraPanYState));

            // Bind inputs to event listeners
            inputs.enable();
        }

        // This shader will be used to draw models imported from the package. If you
        // don't pass a shader to the asset catalog then it will use a default shader
        shader = frag.Shader()
            .name("Model")
            .diffuseTexture()
            .directionalLightGrey()
            .colorsRGB()
            .compile();

        // An asset catalog contains named materials and models. We will load models
        // into the catalog but define the materials manualls
        const assetCatalog = frag.AssetCatalog(shader);

        // Helper function to set a named material to a 1x1 pixel diffuse texture.
        // Note that texture bitmaps use values 0..255 for the pixels
        const singleColorMaterial = function(name, rgb) {
            texture = frag.Texture()
                .dataFormat(frag.gl.RGB)
                .fromArrayBuffer(0, new Uint8Array(rgb), 0, 1, 1);
            assetCatalog.getMaterial(name)
                .setTexture('diffuse', texture);
        }

        // These material names are the ones defined in Blender for the models we are importing
        // we can set up these materials before or after loading the model packages. We can
        // also load material packages instead of hard coding the materials like this
        singleColorMaterial("Plastic", [210, 210, 255]);
        singleColorMaterial("Metal", [220, 175, 175]);
        singleColorMaterial("Rubber", [120, 90, 90]);

        // We need to load the package with the correct endiness
        const packageUrl = frag.ModelLoader.littleEndian ? 'assets/models_little.pkg' : 'assets/models_big.pkg';

        // Download the model package and add the models in it to the asset catalog
        // When loading completes, the modelsLoaded() function will be called
        frag.ModelLoader.loadModelsFromUrl(packageUrl, assetCatalog, modelsLoaded)

    </script>
</body>
