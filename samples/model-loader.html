<!DOCTYPE html>
<html xmlns='http://www.w3.org/1999/xhtml' lang='en-US'>
<head>
    <title>Model Loader</title>
    <meta name='viewport' content='width=device-width, initial-scale=1.0' />
    <style>
        html,
        body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #scene {
            width: 100vw;
            height: 100vh;
            touch-action: none;
            display: block;
        }
    </style>
</head>
<body>
    <canvas id='scene'></canvas>
    <script src='frag.min.js'></script>
    <script>
        // **********************************************************************
        // First of all we need to configure and initialize Frag
        // **********************************************************************

        const frag = window.frag;

        frag.config = function() {
            frag.debugModelLoader = true;
            frag.debugAnimations = false;
            frag.debugShaderBuilder = false;
            frag.debugInputs = true;
        }
        frag.init();

        // **********************************************************************
        // Next we need to define a scene and a camera that projects 
        // the scene onto the canvas.
        // **********************************************************************

        const degToRad = Math.PI / 180;

        const camera = frag.PerspectiveCamera()
            .frustrum(35 * degToRad, -100, 100)
            .scaleX(100)
            .moveToZ(-120);

        const scene = frag.Scene()
            .camera(camera);

        frag.mainScene(scene);

        // **********************************************************************
        // Define a function that will get called after the models have finished 
        // loading into an asset catalog. The asset catalog that the models were 
        // loaded into is passed as a parameter.
        // **********************************************************************

        const modelsLoaded = function(assetCatalog) {
            // **********************************************************************
            // Now that the model package is finished loading into out asset catalog
            // we can add one of these model to the scene.
            // **********************************************************************

            // Get the "excavator" model that was loaded and override the shading algorithm
            const excavatorModel = assetCatalog.getModel('excavator_nla')
                .shadeSmooth();

            // Create an excavator from the model and add it to the scene
            const excavator = frag.SceneObject(excavatorModel);
            excavator.getPosition()
                .scale(10)
                .rotateY(-15 * degToRad)
                .rotateX(-15 * degToRad)
                .moveByXYZ(0, -30, 0);
            scene.addObject(excavator);

            // **********************************************************************
            // Next we are going to define an animation sequence for
            // the excavator that has four steps that repeat in a loop
            // 1. Move the excavator to the left side of the scene
            // 2. Do some excavating
            // 3. Move the excavator to the right side of the scene
            // 4. Tip out the contents of the excavator
            // 5. Go back to step 1
            // **********************************************************************

            const invLinearVelocity = 3;
            const position = excavator.getPosition();

            // Step 1 in the animation sequence
            // Move the excavator from to position -80 on the x-axis whilst running the "moving" animation
            // The "moving" animation was defined in Blender, you can open the `.blend` file to see it.
            const step1 = frag.PositionAnimationAction(position, invLinearVelocity)
                .moveTo([-80, -30, 0])
                .onStart(excavator.animations.moving.start)
                .onStop(excavator.animations.moving.stop);

            // Step 2 in the animation sequence
            // Run the "excavating" animation 4 times. The "moving" animation was defined in Blender, 
            // you can open the `.blend` file to see how it is defined.
            const step2 = frag.RepeatAnimationAction(excavator.animations.excavating, 4)

            // Step 3 in the animation sequence
            // Move the excavator by +100 units on the x-axis whilst running the "moving" animation
            const step3 = frag.PositionAnimationAction(position, invLinearVelocity)
                .moveBy([100, 0, 0])
                .onStart(excavator.animations.moving.start)
                .onStop(excavator.animations.moving.stop);

            // Step 4 in the animation sequence
            // Run the "tipping" animation exactly once
            const step4 = excavator.animations.tipping;

            // Add the steps to an animation sequence and start it running
            const animation = frag.Animation().sequence([step1, step2, step3, step4], true);
            animation.start();

            // **********************************************************************
            // Next we are going to define some player inputs that control
            // various things in the scene. The pattern we use here is that an
            // "input" changes a "state" which triggers an "action". These
            // inputs, states and actions exist in both digital and analog versions.
            // **********************************************************************

            // Define a custom wireframe display "digital state". When this state
            // is "on" the selected model will be drawn in wireframe. The state
            // change handler assumes that state changes are trigged by a mouse event
            // and uses the mouse location to select the model to wireframe
            let wireframeModel = null;
            const wireframeStateChange = function(digitalState, evt) {
                if (digitalState.isOn) {
                    const hit = frag.hitTest(evt.clientX, evt.clientY);
                    if (hit) {
                        wireframeModel = hit.model;
                        wireframeModel.wireframe(true);
                    }
                } else {
                    if (wireframeModel) {
                        wireframeModel.wireframe(false);
                        wireframeModel = null;
                    }
                }
            };
            const wireframeState = frag.DigitalState(wireframeStateChange, { isOn: false }, "wireframe");

            // This is very similar to the wireframe example above, but turns on the
            // drawing of normal vectors on the model
            let normalsModel = null;
            const normalsStateChange = function(digitalState, evt) {
                if (digitalState.isOn) {
                    const hit = frag.hitTest(evt.clientX, evt.clientY);
                    if (hit) {
                        normalsModel = hit.model;
                        normalsModel.drawNormals(1);
                    }
                } else {
                    if (normalsModel) {
                        normalsModel.drawNormals(0);
                        normalsModel = null;
                    }
                }
            }
            const normalsState = frag.DigitalState(normalsStateChange, { isOn: false }, "normals");

            // Define a DigitalState for the excavator visibility with an aassociated
            // DigitalAction that hides and shows the excavator in the scene
            const excavatorVisibilityState = frag.DigitalState(
                frag.DigitalAction("sceneobject", { sceneObject: excavator }), 
                { isOn: true }, 
                "excavator visibility");

            // Define a DigitalState for the excavator bucket visibility with an aassociated
            // DigitalAction that hides and shows the bucket in the excavator model. This would
            // affect all excavators in the scene if there were more than one.
            const excavatorModelChildren = [];
            excavatorModel.addFlattenedChildren(excavatorModelChildren, (child) => child.getName() === "bucket");
            const bucketVisibilityState = frag.DigitalState(
                frag.DigitalAction("model", { model: excavatorModelChildren[0] }), 
                { isOn: true }, 
                "bucket visibility");

            // Define a DigitalState where the state change action is a custom function that writes to the console
            const customState = frag.DigitalState(
                (state) => { console.log("Custom digital state is " + (state.isOn ? "on" : "off")) },
                { isOn: false },
                "custom flag");

            // Define a DigitalState for the animation with an associated DigitalAction that starts and stops
            // the animation
            const animationState = frag.DigitalState(
                frag.DigitalAction("animation", { animation }),
                { isOn: true },
                "animation running");

            // Use AnalogState and AnalogAction to allow the player to move the camera on the z-axis
            const cameraZoomState = frag.AnalogState(
                frag.AnalogAction("move-camera-z"),
                {   value: -120,
                    minValue: -500,
                    maxValue: 0,
                    maxVelocity: 20,
                    acceleration: 0.5,
                    deceleration: 2,
                },
                "camera zoom");

            // Use AnalogState and AnalogAction to allow the player to move the camera on the x-axis
            const cameraPanXState = frag.AnalogState(
                frag.AnalogAction("move-camera-x"),
                {   minValue: -100,
                    maxValue: 100,
                },
                "camera pan X");

            // Use AnalogState and AnalogAction to allow the player to move the camera on the y-axis
            const cameraPanYState = frag.AnalogState(
                frag.AnalogAction("move-camera-y"),
                {   minValue: -100,
                    maxValue: 100,
                },
                "camera pan Y");

            // Use AnalogState and AnalogAction to allow the player to rotate the camera around the z-axis
            const cameraRotateState = frag.AnalogState(
                frag.AnalogAction("rotate-camera-z"),
                {   minValue: -Math.PI / 2,
                    maxValue: Math.PI / 2,
                },
                "camera rotate");

            // Create some input bindings and associate them with the "state" that they control.
            // Group inputs into an InputMethod so that they can be turned on and off as a set.

            // Note that you can create as many InputMethod instances as you need and turn them
            // on and off to determine which inputs do what at various times thoughout the game.

            // You should consider providing a UI that allows the player to customize the input
            // bindings to match their device hardware and playing style.

            const inputs = frag.InputMethod()
                .add(frag.DigitalInput("middle-mouse", wireframeState))
                .add(frag.DigitalInput("right-mouse", normalsState))
                .add(frag.DigitalInput("ctrl-a-key", customState))
                .add(frag.DigitalInput("q-key-toggle", excavatorVisibilityState))
                .add(frag.DigitalInput("e-key-toggle", bucketVisibilityState))
                .add(frag.DigitalInput("r-key-toggle", animationState))
                .add(frag.DigitalInput("t-key-inverted", animationState))
                .add(frag.DigitalInput("y-key-off", animationState))
                .add(frag.DigitalInput("u-key-on", animationState));
            inputs
                .add(frag.AnalogInput("mouse-wheel", cameraZoomState))
                .add(frag.AnalogInput("left-mouse-horizontal-inverted", cameraPanXState))
                .add(frag.AnalogInput("left-mouse-vertical-inverted", cameraPanYState))
                .add(frag.AnalogInput("touch-pinch", cameraZoomState))
                .add(frag.AnalogInput("touch-rotate", cameraRotateState))
                .add(frag.AnalogInput("1-plus-touch-horizontal-inverted", cameraPanXState))
                .add(frag.AnalogInput("1-plus-touch-vertical-inverted", cameraPanYState))
                .add(frag.AnalogInput("keys-d-a", cameraPanXState))
                .add(frag.AnalogInput("keys-w-s", cameraPanYState));

            // Bind all inputs to event listeners
            inputs.enable();
        }

        // **********************************************************************
        // Next we are going to download a package of models from the server and add
        // them to an asset catalog. We also need to define a shader to draw the
        // models and some materials to paint them with
        // **********************************************************************

        // This shader will be used to draw models imported from the package. If you
        // don't pass a shader to the asset catalog then it will use a default shader
        shader = frag.Shader()
            .name("Model")
            .diffuseTexture()
            .directionalLightGrey()
            .colorsRGB()
            .compile();

        // An asset catalog contains named materials and models. We will load models
        // into the catalog but define the materials manually
        const assetCatalog = frag.AssetCatalog(shader);

        // Helper function to set a named material to a 1x1 pixel diffuse texture.
        // Note that texture bitmaps use values 0..255 for the pixels
        const singleColorMaterial = function(name, rgb) {
            texture = frag.Texture()
                .dataFormat(frag.gl.RGB)
                .fromArrayBuffer(0, new Uint8Array(rgb), 0, 1, 1);
            assetCatalog.getMaterial(name)
                .setTexture('diffuse', texture);
        }

        // These material names are the ones defined in Blender for the models we are importing
        // we can set up these materials before or after loading the model packages. We can
        // also load material packages instead of hard coding the materials like this
        singleColorMaterial("Plastic", [210, 210, 255]);
        singleColorMaterial("Metal", [220, 175, 175]);
        singleColorMaterial("Rubber", [120, 90, 90]);

        // We need to load the package with the correct endiness
        const packageUrl = frag.ModelLoader.littleEndian ? 'assets/models_little.pkg' : 'assets/models_big.pkg';

        // Download the model package and add the models in it to the asset catalog
        // When loading completes, the modelsLoaded() function will be called
        frag.ModelLoader.loadModelsFromUrl(packageUrl, assetCatalog, modelsLoaded)

    </script>
</body>